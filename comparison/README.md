Compile executables by calling `make`.

In testing, `n = 1e3 / 1e4 / 1e5 / 5e5`, and `m = 1e8 / 2e8 / 2e9 / 1e10`. (more care is needed with larger values)

Tests of type `00/01` can be generated by calling:
`./generatorExecutables/generator $n$ $m$ $number in [1..29]$ $number in {0, 1}$ > input.txt`

Tests of type `10/11` can be generated by calling:
`./generatorExecutables/generatorPeriod $n$ $m$ $number in [1..29]$ $number in {0, 1}$ > input.txt`

Tests of type `20/21` can be generated by calling:
`./generatorExecutables/generatorFibonacci $n$ $m$ $number in [1..29]$ $number in {0, 1}$ > input.txt`

For example, one such run could look like:
```
> ./generatorExecutables/generatorFibonacci 100000 2000000000 7 1 > input.txt
> source runExecutables 
./executables/ahoCorasick_neal:  s.
./executables/myOffline: 15.89 s.
./executables/suffixArray_ILHY: 32.43 s.
./executables/suffixAutomaton_randmod3: 11.51 s.
./executables/suffixTree_elaina: 2.63 s.
```

In this case, AC doesn't have a time shown because it broke the 40 second barrier we put in the script.

Runtimes and their relative order also depend on the amount of the available cache on the testing machine. The example run was done on a laptop with an `Intel i5-8250U 1.60GHz, 6 MB` of cache. On a machine with an `Intel Xeon E5-2640 2.60GHz, 20 MB` of cache `myOffline` and `suffixArray_ILHY` both take around `17`s.
